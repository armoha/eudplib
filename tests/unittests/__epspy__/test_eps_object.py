## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH
# (Line 1) object Test {
# (Line 2) var x, y, z;
class Test(EUDStruct):
    # (Line 3) function constructor_static() {}
    def constructor_static(this):
        # (Line 4) function setX(x) { this.x = x; }
        pass

    @EUDMethod
    def setX(this, x):
        _ATTW(this, 'x') << (x)
        # (Line 5) function add(other: selftype) {

    @EUDTypedMethod([selftype])
    def add(this, other):
        # (Line 6) this.x += other.x;
        _ATTW(this, 'x').__iadd__(other.x)
        # (Line 7) this.y += other.y;
        _ATTW(this, 'y').__iadd__(other.y)
        # (Line 8) this.z += other.z;
        _ATTW(this, 'z').__iadd__(other.z)
        # (Line 9) }
        # (Line 10) };

    # (Line 11) function test_object() {
    _fields_ = [
        'x',
        'y',
        'z',
    ]

@EUDFunc
def f_test_object():
    # (Line 12) const a = Test();
    a = Test()
    # (Line 13) a.x, a.y = 5, 7;
    _SV([_ATTW(a, 'x'), _ATTW(a, 'y')], [5, 7])
    # (Line 15) const b = Test.cast(a);
    b = Test.cast(a)
    # (Line 16) const c = Test.cast(b);
    c = Test.cast(b)
    # (Line 18) b.z = 8;
    _ATTW(b, 'z') << (8)
    # (Line 19) c.x = 3;
    _ATTW(c, 'x') << (3)
    # (Line 22) var ret = a ? 1 : 0;
    ret = _LVAR([EUDTernary(a)(1)(0)])
    # (Line 23) if (a.x == b.x && b.x == c.x) ret += 2;
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'x') == b.x)(_ATTC(b, 'x') == c.x)()):
        ret.__iadd__(2)
        # (Line 24) if (a.y == b.y && b.y == c.y) ret += 4;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'y') == b.y)(_ATTC(b, 'y') == c.y)()):
        ret.__iadd__(4)
        # (Line 25) if (a.z == b.z && b.z == c.z) ret += 8;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'z') == b.z)(_ATTC(b, 'z') == c.z)()):
        ret.__iadd__(8)
        # (Line 26) if (a.x == 3 && b.y == 7 && c.z == 8) ret += 16;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'x') == 3)(_ATTC(b, 'y') == 7)(_ATTC(c, 'z') == 8)()):
        ret.__iadd__(16)
        # (Line 28) const d = a.copy();
    EUDEndIf()
    d = a.copy()
    # (Line 29) a.add(d);
    a.add(d)
    # (Line 30) if (c.x == 6 && a.y == 14 && b.z == 16) ret += 32;
    if EUDIf()(EUDSCAnd()(_ATTC(c, 'x') == 6)(_ATTC(a, 'y') == 14)(_ATTC(b, 'z') == 16)()):
        ret.__iadd__(32)
        # (Line 31) if (d.x == 3 && d.y == 7 && d.z == 8) ret += 64;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(d, 'x') == 3)(_ATTC(d, 'y') == 7)(_ATTC(d, 'z') == 8)()):
        ret.__iadd__(64)
        # (Line 33) var e = a;
    EUDEndIf()
    e = _LVAR([a])
    # (Line 34) Test.cast(e).setX(1);
    Test.cast(e).setX(1)
    # (Line 35) if (a.x == 1) ret += 128;
    if EUDIf()(_ATTC(a, 'x') == 1):
        ret.__iadd__(128)
        # (Line 36) Test.cast(e).add(d);
    EUDEndIf()
    Test.cast(e).add(d)
    # (Line 37) if (b.x == 4 && c.y == 21 && a.z == 24) ret += 256;
    if EUDIf()(EUDSCAnd()(_ATTC(b, 'x') == 4)(_ATTC(c, 'y') == 21)(_ATTC(a, 'z') == 24)()):
        ret.__iadd__(256)
        # (Line 39) return ret;  // 511
    EUDEndIf()
    EUDReturn(ret)
    # (Line 40) }
    # (Line 42) object Coord { var x, y; };

class Coord(EUDStruct):
    # (Line 43) object Triangle {
    _fields_ = [
        'x',
        'y',
    ]

# (Line 44) var p: Coord * 5;
class Triangle(EUDStruct):
    # (Line 45) var q;
    # (Line 46) };
    # (Line 47) function test_nested_object() {
    _fields_ = [
        ('p', Coord * 5),
        'q',
    ]

@EUDFunc
def f_test_nested_object():
    # (Line 48) const a = Triangle();
    a = Triangle()
    # (Line 49) a.p = (Coord * 5)();
    _ATTW(a, 'p') << ((Coord * 5)())
    # (Line 50) foreach(i : py_range(5)) {
    for i in range(5):
        # (Line 51) a.p[i] = Coord();
        _ARRW(a.p, i) << (Coord())
        # (Line 52) }
        # (Line 54) a.p[0].x = 1;

    _ATTW(a.p[0], 'x') << (1)
    # (Line 55) a.p[1].y = 2;
    _ATTW(a.p[1], 'y') << (2)
    # (Line 56) a.p[1].y += 2;
    _ATTW(a.p[1], 'y').__iadd__(2)
    # (Line 57) a.q = 3;
    _ATTW(a, 'q') << (3)
    # (Line 59) var ret = list(a.p[0].x == 1, a.p[0].y == 0, a.p[1].y == 4, a.q == 3) ? 1 : 0;
    ret = _LVAR([EUDTernary(FlattenList([_ATTC(a.p[0], 'x') == 1, _ATTC(a.p[0], 'y') == 0, _ATTC(a.p[1], 'y') == 4, _ATTC(a, 'q') == 3]))(1)(0)])
    # (Line 61) const b = a.copy();
    b = a.copy()
    # (Line 62) b.p[0].x = 5;
    _ATTW(b.p[0], 'x') << (5)
    # (Line 63) b.q = 2;
    _ATTW(b, 'q') << (2)
    # (Line 64) if (a.p[0].x == 5) ret += 2;
    if EUDIf()(_ATTC(a.p[0], 'x') == 5):
        ret.__iadd__(2)
        # (Line 65) if (b.p[0].x == 5) ret += 4;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[0], 'x') == 5):
        ret.__iadd__(4)
        # (Line 66) if (b.p[0].y == 0) ret += 8;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[0], 'y') == 0):
        ret.__iadd__(8)
        # (Line 67) if (b.p[1].y == 4) ret += 16;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[1], 'y') == 4):
        ret.__iadd__(16)
        # (Line 68) if (a.q == 3) ret += 32;
    EUDEndIf()
    if EUDIf()(_ATTC(a, 'q') == 3):
        ret.__iadd__(32)
        # (Line 69) if (b.q == 2) ret += 64;
    EUDEndIf()
    if EUDIf()(_ATTC(b, 'q') == 2):
        ret.__iadd__(64)
        # (Line 71) return ret;
    EUDEndIf()
    EUDReturn(ret)
    # (Line 72) }
    # (Line 74) const ListList = py_list();

ListList = _CGFW(lambda: [list()], 1)[0]
# (Line 75) var AllList;  // EUDArray
AllList = EUDVariable()
# (Line 76) object List {
# (Line 77) var prev: selftype, next: selftype;
class List(EUDStruct):
    # (Line 78) function constructor() {
    @EUDMethod
    def constructor(this):
        # (Line 79) py_exec("\
        # (Line 85) EUDOnStart(init)");
        exec("if not ListList:\n    def init():\n        global AllList\n        ListList.append(-1)\n        AllList << EUDArray(ListList)\n    EUDOnStart(init)")
        # (Line 86) ListList.append(this);
        ListList.append(this)
        # (Line 87) }
        # (Line 88) function foo(c: Coord) {}

    @EUDTypedMethod([Coord])
    def foo(this, c):
        # (Line 89) };
        pass

    # (Line 90) function test_selftype_member() {
    _fields_ = [
        ('prev', selftype),
        ('next', selftype),
    ]

@EUDFunc
def f_test_selftype_member():
    # (Line 91) const a, b = List(), List();
    a, b = List2Assignable([List(), List()])
    # (Line 92) a.prev = b;
    _ATTW(a, 'prev') << (b)
    # (Line 93) a.next = b;
    _ATTW(a, 'next') << (b)
    # (Line 94) b.prev = a;
    _ATTW(b, 'prev') << (a)
    # (Line 95) b.next = a;
    _ATTW(b, 'next') << (a)
    # (Line 96) a.foo(0);
    a.foo(0)
    # (Line 97) const c = List();
    c = List()
    # (Line 98) const d = List();
    d = List()
    # (Line 99) const e = List();
    e = List()
    # (Line 101) const arr = EUDArray.cast(AllList);
    arr = EUDArray.cast(AllList)
    # (Line 102) var i;
    i = EUDVariable()
    # (Line 103) for (i = 0 ; arr[i] != -1 ; i++) {}
    i << (0)
    if EUDWhile()(_ARRC(arr, i) == -1, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 104) return i;
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDReturn(i)
    # (Line 105) }
